error.adaptive.size.policy.disabled=Adaptive size policy is disabled (-XX:-UseAdaptiveSizePolicy), and minimum heap size (-Xms, -XX:InitialHeapSize) and maximum heap size (-Xmx, -XX:MaxHeapSize) are not equal. The JVM will not be able to increase the heap beyond the minimum heap size. Remove -XX:-UseAdaptiveSizePolicy. Reference: https://access.redhat.com/solutions/5565311.
error.cms.concurrent.mode.failure=Concurrent mode failure. The concurrent collection of the old or perm generation did not finish before the old or perm generation became full. The JVM initiates a full GC using a slow (single threaded) serial collector in an attempt to free space. There is not enough space in the old generation to support the rate of promotion from the young generation or in the perm gen to support the rate of perm gen usage. The concurrent low pause collector measures the rate at which the the old generation is filling and the amount of time between collections and uses this historical data to calculate when to start the concurrent collection (plus adds some padding) so that it will finish just in time before the old generation becomes full. Possible causes: (1) The heap is too small. (2) There is a change in application behavior (e.g. a load increase) that causes the young promotion rate to exceed historical data. If this is the case, the concurrent mode failures will happen near the change in behavior, then after a few collections the CMS collector will adjust based on the new promotion rate. Performance will suffer for a short period until the CMS collector recalibrates. Use -XX:CMSInitiatingOccupancyFraction=N (default 92) to handle changes in application behavior (e.g. -XX:CMSInitiatingOccupancyFraction=85 -XX:+UseCMSInitiatingOccupancyOnly); however, the tradeoff is that there will be more collections. (3) The application has large variances in object allocation rates, causing large variances in young generation promotion rates, leading to the CMS collector not being able to accurately predict the time between collections. Use -XX:CMSIncrementalSafetyFactor=N (default 10) to start the concurrent collection NN% sooner than the calculated time. (4) There is premature promotion from the young to the old generation, causing the old generation to fill up with short-lived objects. The default value for -XX:MaxTenuringThreshold for the CMS collector is 0, meaning that objects surviving a young collection are immediately promoted to the old generation. Use -XX:MaxTenuringThreshold=32 to allow more time for objects to expire in the young generation. (5) If the old generation has available space, the cause is likely fragmentation. Fragmentation can be avoided by increasing the heap size, moving to the G1 collector which compacts the young and old generation during evacuation, or doing heap dump analysis to determine if there is any unintended object retention that can be addressed to decrease heap demands. (6) The Perm gen fills up during the CMS cycle. Increase the perm gen size. For example: -XX:PermSize=256M -XX:MaxPermSize=256M.
error.cms.concurrent.mode.interrupted=The concurrent collection of the old generation was interrupted by user requested GC (e.g. System.gc(), JVMTI ForceGarbageCollection) or serviceability requested GC (JVMTI ForceGarbageCollection, Heap Inspection, Heap Dump).
error.cms.par.new.gc.locker.failed=GCLocker initiated PAR_NEW collection failed due to there not being enough space in the old generation for the worst case scenario where all objects are promoted to the old generation (the young generation guarantee). Check if the old generation has available space, but it is not contiguous. When fragmentation is an issue, the concurrent low pause collector invokes a slow (single-threaded) serial collector to compact the heap. Tune to avoid fragmentation: (1) Increase the heap size. (2) Use -XX:CMSInitiatingOccupancyFraction=N (default 92) to run the CMS cycle more frequently to increase sweeping of dead objects in the old generation to free lists (e.g. -XX:CMSInitiatingOccupancyFraction=85 -XX:+UseCMSInitiatingOccupancyOnly). (3) Do heap dump analysis to determine if there is unintended object retention that can be addressed to decrease heap demands. Or move to a collector that handles fragmentation more efficiently: (1) G1 compacts the young and old generations during evacuation using a multi-threaded collector. (2) Shenandoah compacts concurrently. Temporarily add -XX:PrintFLSStatistics=1 and -XX:+PrintPromotionFailure to get additional insight into fragmentation.
error.cms.parallel.initial.mark.disabled=Multi-threaded CMS initial mark is disabled with -XX:-CMSParallelInitialMarkEnabled. Replace -XX:-CMSParallelInitialMarkEnabled  with -XX:+CMSParallelInitialMarkEnabled.
error.cms.parallel.remark.disabled=Multi-threaded CMS remark is disabled with -XX:-CMSParallelRemarkEnabled. Replace -XX:-CMSParallelRemarkEnabled  with -XX:+CMSParallelRemarkEnabled.
error.cms.promotion.failed=CMS promotion failed. A young generation collection is not able to complete because there is not enough space in the old generation for promotion. The old generation has available space, but it is not contiguous. When fragmentation is an issue, the concurrent low pause collector invokes a slow (single-threaded) serial collector to compact the heap. Tune to avoid fragmentation: (1) Increase the heap size. (2) Use -XX:CMSInitiatingOccupancyFraction=N (default 92) to run the CMS cycle more frequently to increase sweeping of dead objects in the old generation to free lists (e.g. -XX:CMSInitiatingOccupancyFraction=85 -XX:+UseCMSInitiatingOccupancyOnly). (3) Do heap dump analysis to determine if there is unintended object retention that can be addressed to decrease heap demands. Or move to a collector that handles fragmentation more efficiently: (1) G1 compacts the young and old generations during evacuation using a multi-threaded collector. (2) Shenandoah compacts concurrently. Temporarily add -XX:PrintFLSStatistics=1 and -XX:+PrintPromotionFailure to get additional insight into fragmentation.
error.cms.serial.old=Add -XX:+UseConcMarkSweepGC to use the CMS collector for the old generation. When -XX:+UseParNewGC is used alone the CMS collector is only used to collect the young generation, and the older, slower serial collector is used to collect the old generation.
error.comp.class.disabled.heap.lt.32g=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Garbage collection time typically increases with heap size. Enable compressed class pointers with -XX:+UseCompressedClassPointers, so references can be compressed to 32 bits, allowing class pointer sizes on the order of 32-bit.
error.comp.class.enabled.heap.gt.32g=Compressed class pointers are enabled with -XX:+UseCompressedClassPointers, and heap >= 32G. Disable compressed class pointers with -XX:-UseCompressedClassPointers, as compressed object references should not be used on heaps >= 32G.
error.comp.class.size.heap.gt.32g=Compressed class pointers space size is set (-XX:CompressedClassSpaceSize), and heap >= 32G. Remove -XX:CompressedClassSpaceSize, as compressed object references should not be used on heaps >= 32G.
error.comp.class.space.undersized=Full garbage collections triggered by "Metadata GC Threshold". The allocation failure is due to undersized compressed class space. Remove -XX:CompressedClassSpaceSize to allow the default 1G size, or set a size larger than 1G (e.g. -XX:CompressedClassSpaceSize=1536M). Reference: https://access.redhat.com/solutions/2743461.
error.comp.oops.disabled.heap.lt.32g=Compressed object references are disabled with -XX:-UseCompressedOops, and heap < 32G. One disadvantage of 64-bit is increased heap size due to increased pointer size. Garbage collection time typically increases with heap size. Enable compressed object references with -XX:+UseCompressedOops, so references can be compressed to 32 bits, allowing heap sizes on the order of 32-bit.
error.comp.oops.enabled.heap.gt.32g=Compressed object references are enabled with -XX:+UseCompressedOops, and heap >= 32G. Disable compressed object references with -XX:-UseCompressedOops, as compressed object references should not be used on heaps >= 32G.
error.datestamp.no.timestamp=The GC logging has datestamps but no timestamps. Timestamps are required for garbagecat analysis. Pass in the JVM start datetime (e.g. the value in the first GC log line) with the -s "yyyy-MM-dd HH:mm:ss,SSS" option (e.g. -s "2017-02-28 10:15:00,000"). Consider enabling timestamps with the -XX:+PrintGCTimeStamps option.
error.explicit.gc.serial.cms=Explicit garbage collection, i.e. calls to System.gc(), is causing the slow, single threaded CMS_SERIAL_OLD collector to be invoked. Either add -XX:+DisableExplicitGC to disable explicit garbage collection, or add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently. Do not use -XX:+DisableExplicitGC if any of the following apply: (1) The application makes use of a direct buffer (e.g. java.nio.DirectByteBuffer) in combination with -XX:MaxDirectMemorySize=N[K|M|G], as the JVM uses explicit garbage collection to try to free space when MaxDirectMemorySize is reached. (2) The application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid explicit garbage collection. Reference: https://access.redhat.com/solutions/21994
error.explicit.gc.serial.g1=Explicit garbage collection, i.e. calls to System.gc(), is causing the slow, single threaded G1_FULL_GC collector to be invoked. Either add -XX:+DisableExplicitGC to disable explicit garbage collection, or add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently. Do not use -XX:+DisableExplicitGC if any of the following apply: (1) The application makes use of a direct buffer (e.g. java.nio.DirectByteBuffer) in combination with -XX:MaxDirectMemorySize=N[K|M|G], as the JVM uses explicit garbage collection to try to free space when MaxDirectMemorySize is reached. (2) The application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid explicit garbage collection. Reference: https://access.redhat.com/solutions/21994
error.gc.time.limit.exceeded=The garbage collection overhead limit was reached. This happens when 98% of the total time is spent in garbage collection and less than 2% of the heap is recovered. This feature is a throttle to prevent applications from running for an extended period of time while making little or no progress because the heap is too small. If desired, this feature can be disabled with the -XX:-UseGCOverheadLimit option (e.g. to avoid "OutOfMemoryError: GC overhead limit exceeded", which does not initiate a heap dump when using -XX:+HeapDumpOnOutOfMemoryError, hoping to reach "OutOfMemoryError: Java heap space", which will trigger a heap dump with -XX:+HeapDumpOnOutOfMemoryError).
error.g1.evacuation.failure=A G1_YOUNG_PAUSE, G1_MIXED_PAUSE, and/or G1_YOUNG_INITIAL_MARK collection cannot happen due to "to-space exhausted" or "to-space overflow". There is not enough free space in the heap for survived and/or promoted objects, and the heap cannot be expanded. This is a very expensive operation. The Collection Set (CSet) and Remember Set (RSet) are fully re-scanned to understand the heap status, and the collector's ergonomics attempt to resolve the issue by dynamically re-sizing heap regions. If it cannot, it invokes a G1_FULL_GC in an attempt to reclaim enough space to continue. All of the following are possible resolutions: (1) Increase the heap size. (2) Increase -XX:G1ReservePercent (default 10%) and the heap size to increase the amount of to-space reserve memory. For, example, if you increase the reserve by 5% (to 15), you would also need to increase the heap size by 5%. (3) Reduce the -XX:InitiatingHeapOccupancyPercent (default 45) to start the marking cycle earlier. For example: -XX:InitiatingHeapOccupancyPercent=40. (4) Increase the number of parallel marking threads with -XX:ConcGCThreads. For example: -XX:ConcGCThreads=16. To determine which option is most appropriate, do analysis with ergonomic logging enabled with the -XX:+PrintAdaptiveSizePolicy option.
error.g1.humongous.jdk.old=Humongous objects are being allocated on an old version of the JDK that is not able to fully reclaim humongous objects during young collections. Upgrade to JDK8 update 60 or later.
error.metaspace.allocation.failure=Metaspace allocation failure. The Metaspace is not able to be resized, and the JVM is doing full, serial collections attempting to free Metaspace. The class metadata or compressed class pointers space is undersized, or there is a Metaspace leak. Increase the class metadata and compressed class pointers spaces to sufficiently large values to observe if there is a runaway leak or Metaspace usage levels off. For example, the following options will result in a 1536M Metaspace with a 512M space for class metadata and 1G space for compressed class pointers: -XX:MetaspaceSize=1536M -XX:MaxMetaspaceSize=1536M -XX:CompressedClassSpaceSize=1G.
error.metaspace.size.lt.comp.class.size=MaxMetaspaceSize is less than CompressedClassSpaceSize. MaxMetaspaceSize includes CompressedClassSpaceSize, so MaxMetaspaceSize should be larger than CompressedClassSpaceSize. If MaxMetaspaceSize is set smaller than CompressedClassSpaceSize, the JVM auto adjusts CompressedClassSpaceSize as follows: CompressedClassSpaceSize = MaxMetaspaceSize - (2 * InitialBootClassLoaderMetaspaceSize).
error.physical.memory=The memory reserved for the heap and perm/metaspace is greater than the physical memory. This can lead to swapping (very bad for Java performance) or the process being terminated (oom killer). Either increase physical memory or decrease heap and/or perm/metaspace size to avoid swapping. The memory required by the JVM process is the sum of the following: (1) Heap. (2) Perm/Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory. (5) A safety factor.
error.serial.gc=A SERIAL collector is being invoked. SERIAL collectors are single-threaded, which means they can take a long time to collect a large heap. For optimal performance on multi cpu/core systems, tune to avoid serial collections.
error.serial.gc.cms=The CMS_SERIAL_OLD collector is being invoked for one of the following reasons: (1) Fragmentation. The concurrent low pause collector does not compact. When fragmentation becomes an issue a serial collection compacts the heap. If the old generation has available space, the cause is likely fragmentation. Fragmentation can be avoided by increasing the heap size. (2) Metaspace class metadata or compressed class pointers allocation failure. The GC attempts to free/resize metaspace. (3) Resizing perm gen. If perm gen occupancy is near perm gen allocation, the cause is likely perm gen. Perm gen resizing can be avoided by setting the minimum perm gen size equal to the the maximum perm gen size. For example: -XX:PermSize=256M -XX:MaxPermSize=256M. (4) Undetermined reasons. Possibly the JVM requires a certain amount of heap or combination of resources that is not being met, and consequently the concurrent low pause collector is not used despite being specified with the -XX:+UseConcMarkSweepGC option. The CMS_SERIAL_OLD collector is a serial (single-threaded) collector, which means it will take a very long time to collect a large heap. For optimal performance, tune to avoid serial collections.
error.serial.gc.g1=The G1_FULL_GC collector is being invoked due to the old or perm gen space filling up. Old space causes: (1) It is filled with humongous objects. Humongous objects can only be collected by the G1_FULL_GC collector. (2) The heap is swamped before the marking cycle is able to complete and a mixed collection reclaim space. Reduce the -XX:InitiatingHeapOccupancyPercent (default 45) to start the marking cycle earlier. For example: -XX:InitiatingHeapOccupancyPercent=40. (3) The heap is simply too small, (4) Bugs in JDK7 that cause G1 Full GC collections. For example: http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8030849. The G1_FULL_GC collector is a serial (single-threaded) collector, which means it will take a very long time to collect a large heap. For optimal performance, tune to avoid serial collections.
error.serial.gc.parallel=The PARALLEL_SERIAL_OLD (single-threaded) collector is being invoked. Add -XX:+UseParallelOldGC to use the more efficient PARALLEL_COMPACTING_OLD collector added in JDK 6.
error.unidentified.log.lines.preparse=Unidentified log line(s). Try running with the -p (preparsing) option.   
info.comp.class.size.comp.oops.disabled=Compressed class pointers space size is not being used due to compressed object references being disabled (-XX:-UseCompressedOops).
info.comp.class.size.comp.class.disabled=Compressed class pointers space size is not being used due to compressed class pointers being disabled (-XX:-UseCompressedClassPointers).  
info.comp.class.size.not.set=When UseCompressedOops and UseCompressedClassesPointers (JDK 1.8 u40+) are enabled (default) the Metaspace reported in the GC logging is the sum of two native memory spaces: (1) class metadata. (2) compressed class pointers. The compressed class pointer spaces defaults to 1G and can be explicitly set with -XX:CompressedClassSpaceSize (e.g. -XX:CompressedClassSpaceSize=1280M).
info.cruft.exp.gc.inv.con.and.unl.cla=The option -XX:-ExplicitGCInvokesConcurrentAndUnloadsClasses is unnecessary and can be removed because explicit garbage collection is disabled with -XX:+DisableExplicitGC.
info.diagnostic.vm.options.enabled=Diagnostic JVM options are enabled with -XX:+UnlockDiagnosticVMOptions. Diagnostic options add additional overhead and are intended for troubleshooting issues, not general production use. Remove diagnostic options after completing troubleshooting: (1) safepoint statistics -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1, (2) logging vm output -XX:+LogVMOutput, (3) -XX:+UnsyncloadClass).
info.experimental.vm.options.enabled=Experimental options are enabled with -XX:+UnlockExperimentalVMOptions. Experimental options are generally not recommended for production. Consider removing this option and any related experimental options unless there is a valid use case, and testing has shown it does not introduce any issues.
info.first.timestamp.threshold.exceeded=First timestamp is greater than threshold. Partial log file or unrecognized logging format.
info.g1.humongous.allocation=G1 Humongous allocations. Frequent humongous allocations can cause the heap to become fragmented and/or have excessive unused space (the space between the last humongous object and the end of the region is unused).
info.g1.summarize.rset.stats.output=Summarized remembered set processing output is enabled (e.g. -XX:+G1SummarizeRSetStats -XX:G1SummarizeRSetStatsPeriod=1). This is verbose logging generally enabled for short periods of time to address specific tuning issues. If there is not a good use case for this output, do not enable it.
info.gc.log.file.rotation.disabled=GC log file rotation is disabled (-XX:-UseGCLogFileRotation). Consider enabling rotation to protect disk space.
info.gc.log.file.rotation.not.enabled=GC log file rotation is not enabled. Consider enabling rotation (-XX:+UseGCLogFileRotation -XX:GCLogFileSize=N[K|M|G] -XX:NumberOfGCLogFiles=N) to protect disk space.
info.heap.dump.path.missing=Use the -XX:HeapDumpPath option to specify a directory where heap dumps are created (e.g. -XX:HeapDumpPath=/mypath/). If this option is not used, heap dumps will be created in the directory defined by the user.dir environment variable.
info.instrumentation=Instrumentation is being used (-javaagent).
info.jmx.enabled=JMX is enabled with -Dcom.sun.management.jmxremote or -XX:+ManagementServer. This in and of itself does not add significant overhead; however, there is additional overhead when a tool (e.g. jconsole) polls for information. The impact on performance will depend on what is being polled and how often. 
info.max.tenuring.override=The number of times an object is copied between survivor spaces is being set with -XX:MaxTenuringThreshold=N (0-15). 0 = disabled. 15 (default) = promote when the survivor space fills. Unless testing has shown this improves performance, consider removing this option to allow the default value to be applied.
info.native=Native library is being used (-agentpath).
info.new.ratio.inverted=Young space >= old space.
info.perm.gen=A very old JDK with a permanent generation is being used. The decommissioning of the perm gen space began in JDK7 when interned strings and class static variables were moved to the Java heap, and symbols were moved to the native heap. In JDK8 the perm gen space was fully replaced by the metaspace, a native space holding only class metadata.
info.print.adaptive.resize.plcy.disabled=Adaptive Resize Policy output is disabled with -XX:-PrintAdaptiveSizePolicy. It is disabled by default, so this option is redundant. Verify the intent is not to enable it with XX:+PrintAdaptiveSizePolicy.
info.print.adaptive.resize.plcy.enabled=Adaptive Resize Policy output is enabled with -XX:+PrintAdaptiveSizePolicy. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less verbose logging.
info.print.fls.statistics=The -XX:PrintFLSStatistics option is being used. The additional data output with this option is not typically needed and adds significant logging overhead. If there is not a good use case for using this option, remove it.
info.print.promotion.failure=The -XX:+PrintPromotionFailure option is being used. The additional data output with this option is not generally needed. If there is not a good use case for using this option, consider removing it.
info.survivor.ratio=Survivor ratio, the size of the eden space compared to ONE survivor space, is being set with -XX:SurvivorRatio=N (e.g. -XX:SurvivorRatio=6).
info.survivor.ratio.target=Target survivor ratio, the percentage of the survivor space allowed to be occupied, is being set with -XX:TargetSurvivorRatio=N (e.g. -XX:TargetSurvivorRatio=90).
info.swap.disabled=Swap has been disabled. This can be an indication the JVM is running in a container environment. Reference: https://access.redhat.com/solutions/3242331
info.swapping=Some swap space was being used when the GC log file was created (at JVM startup or file rotation). This is not necessarily bad, as it is only a snapshot in time, and it doesn't necessarily mean the Java process is swapping. Swapping is very bad for Java performance. Verify the Java process is not swapping.
info.unaccounted.options.disabled=Unaccounted disabled JVM options: 
info.unidentified.log.line.last=Last log line not identified. This is typically caused by the GC log being copied while the JVM is in the middle of logging an event, resulting in truncated logging. If it is not due to truncated logging, report the unidentified logging line: https://github.com/mgm3746/garbagecat/issues.
warn.application.logging=Garbage collection logging mixed with application logging. Garbage collection logging should be logged to a dedicated file using the -Xloggc option. For example: -Xloggc:gc.log.`date +%Y%m%d%H%M%S`.
warn.application.stopped.time.missing=Application stopped time missing. Enable with -XX:+PrintGCApplicationStoppedTime (<= JDK8) or with safepoint logging at info level (e.g. -Xlog:gc*,safepoint=info:file=gc.log:uptime:filecount=4,filesize=50M). Required to determine overall throughput and identify throughput and pause issues not related to garbage collection, as many JVM operations besides garbage collection require all threads to reach a safepoint to execute. Reference: https://access.redhat.com/solutions/18656
warn.biased.locking.disabled=Biased locking is a threading optimization that benefits objects that are only locked by a single thread. This is the typical use case, and this option is enabled by default. Remove -XX:-UseBiasedLocking unless testing has shown that disabling biased locking improves performance.
warn.bytecode.compile.background.disabled=Bytecode background compilation is disabled. Remove -Xbatch or -XX:-BackgroundCompilation to compile bytecode in the background so threads do not block waiting but instead run in interpreter mode until the compilation is complete. 
warn.bytecode.compile.disabled=Compilation to native code is disabled. Remove -Xint to allow the just in time (JIT) compiler to compile to native code for increased performance.
warn.bytecode.compile.first.invocation=Methods being compiled on first invocation. Remove -Xcomp to enabled the JVM to efficiently decide when to compile methods into bytecode.
warn.cgroup.memory.limit=Consider removing -XX:+UseCGroupMemoryLimitForHeap, an experimental option replaced by auto-detection of container limits in recent JDKs and removed altogether in JDK 11. See: https://bugs.openjdk.java.net/browse/JDK-8194086.
warn.class.histogram=Class histogram output due to one of the following options: -XX:+PrintClassHistogram, -XX:+PrintClassHistogramBeforeFullGC, -XX:+PrintClassHistogramAfterFullGC. These are heavyweight options that can output tens of thousands of logging lines and have limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for this output, do not enable it.
warn.class.unloading.disabled=Class unloading is disabled with -XX:-ClassUnloading. Replace with -XX:+ClassUnloading to unload unreachable classes to collect Perm/Metaspace.
warn.cms.class.unloading.disabled=CMS collection of Perm/Metaspace is disabled with -XX:-CMSClassUnloadingEnabled. Replace with -XX:+CMSClassUnloadingEnabled to collect Perm/Metaspace in the CMS concurrent cycle and avoid Perm/Metaspace collections being done by a slow (single threaded) serial collector.
warn.cms.class.unloading.not.enabled=The CMS collector does not always collect Perm/Metaspace by default (e.g. prior to JDK 1.8). Add -XX:+CMSClassUnloadingEnabled to collect Perm/Metaspace in the CMS concurrent cycle and avoid Perm/Metaspace collections being done by a slow (single threaded) serial collector.
warn.cms.inc.mode.with.init.occup.fract=When the CMS collector is run in incremental mode, the CMS initiating occupancy fraction is ignored. Remove one of the following options: (1) -XX:+CMSIncrementalMode, (2) -XX:CMSInitiatingOccupancyFraction=<n>.
warn.cms.incremental.mode=The CMS collector is being run in incremental mode. Concurrent phases are periodically stopped so application threads can run. This is useful on systems with 1-2 processors that cannot afford to dedicate cpu to the concurrent phases. Remove -XX:+CMSIncrementalMode if > 2 cpu/cores.
warn.cms.init.occupancy.only.missing=The CMS occupancy fraction, -XX:CMSInitiatingOccupancyFraction=N (default 92), is set without -XX:+UseCMSInitiatingOccupancyOnly enabled. Typically these options are used in combination with applications with large variances in object allocation and young generation promotion rates that prevent the CMS collector from accurately predicting when to start the CMS cycle. Consider adding/enabling -XX:+UseCMSInitiatingOccupancyOnly to disable heuristics (calculating anticipated promotions) and use only the occupancy fraction to determine when to trigger a CMS cycle.
warn.cms.initial.mark.low.parallelism=CMS initial mark low parallelism: (1) If using JDK6 or earlier, initial mark is single-threaded. Consider upgrading to JDK7 or later for multi-threaded initial mark. (2) If using JDK7, add -XX:+CMSParallelInitialMarkEnabled, as initial mark is single-threaded by default in JDK7. (3) Check if multi-threaded remark is disabled with -XX:-CMSParallelInitialMarkEnabled, and replace with -XX:+CMSParallelInitialMarkEnabled. (3) Check for swapping and if the number of GC threads (-XX:ParallelGCThreads=<n>) is appropriate for the number of cpu/cores and any processes sharing cpu.
warn.cms.par.new.disabled=The PAR_NEW collector is disabled with -XX:-UseParNewGC, resulting in the SERIAL_NEW collector being used instead. Serial collectors are single-thread, which means they can take a long time to collect a large heap. For optimal performance on multi cpu/core systems, the PAR_NEW collector should be enabled with -XX:+UseParNewGC.
warn.cms.remark.low.parallelism=CMS remark low parallelism: (1) If using JDK7 or earlier, add -XX:+CMSParallelRemarkEnabled, as remark is single-threaded by default in JDK7 and earlier. (2) Check if multi-threaded remark is disabled with -XX:-CMSParallelRemarkEnabled, and replace with -XX:+CMSParallelRemarkEnabled. (4) Add -XX:+ParallelRefProcEnabled to enable multi-threaded reference processing if the "weak refs processing" time is a significant amount of the total CMS remark time. (5) Check for swapping and if the number of GC threads (-XX:ParallelGCThreads=<n>) is appropriate for the number of cpu/cores and any processes sharing cpu.
warn.comp.class.disabled.heap.unk=Compressed class pointers are disabled with -XX:-UseCompressedClassPointers. One disadvantage of 64-bit is increased heap size due to increased pointer size. Garbage collection time typically increases with heap size. If the heap is < 32G, enable compressed class pointers with -XX:+UseCompressedClassPointers so references can be compressed to 32 bits, allowing class pointer sizes on the order of 32-bit.
warn.comp.oops.disabled.heap.unk=Compressed object references are disabled with -XX:-UseCompressedOops. One disadvantage of 64-bit is increased heap size due to increased pointer size. Garbage collection time typically increases with heap size. If the heap is < 32G, enable compressed object references with -XX:+UseCompressedOops so references can be compressed to 32 bits, allowing heap sizes on the order of 32-bit.
warn.explicit.gc.disabled=Explicit garbage collection has been disabled with -XX:+DisableExplicitGC. The JVM uses explicit garbage collection to manage direct memory (to free space when MaxDirectMemorySize is reached) and the Remote Method Invocation (RMI) system (to clean up unreachable remote objects). Disabling it for those use cases can cause a memory leak. Verify the application does not use direct memory (e.g. java.nio.DirectByteBuffer), does not make remote method calls or export remote objects like EJBs (everything runs in the same JVM), and does not depend on explicit garbage collection in some other way. Known applications that use direct memory: JBoss EAP7 (IO subsystem). If explicit garbage collection is required, remove -XX:+DisableExplicitGC, and if using the CMS or G1 collector, add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently.
warn.explicit.gc.disabled.concurrent=Remove -XX:+ExplicitGCInvokesConcurrent since explicit garbage collection has been disabled with -XX:+DisableExplicitGC.
warn.explicit.gc.g1.young.initial.mark=Explicit garbage collection, i.e. calls to System.gc(), is causing the G1_YOUNG_INITIAL_MARK collector to be invoked. Add -XX:+DisableExplicitGC to disable explicit garbage collection if the application does not depend on explicit garbage collection. Do not use -XX:+DisableExplicitGC if any of the following apply: (1) The application makes use of a direct buffer (e.g. java.nio.DirectByteBuffer) in combination with -XX:MaxDirectMemorySize=N[K|M|G], as the JVM uses explicit garbage collection to try to free space when MaxDirectMemorySize is reached. (2) The application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid explicit garbage collection. Reference: https://access.redhat.com/solutions/21994
warn.explicit.gc.jvmti=The JVM Tools Interface (TI) API is being called (e.g. by some tool) to explicitly invoke garbage collection.
warn.explicit.gc.not.concurrent=Consider adding -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently by the CMS and G1 collectors. Or if not making remote method calls and not exporting remote objects like EJBs (everything runs in the same JVM), disable explicit garbage collection altogether with -XX:+DisableExplicitGC. Reference: https://access.redhat.com/solutions/21994
warn.explicit.gc.parallel=Explicit garbage collection, i.e. calls to System.gc(), is causing the PARALLEL_COMPACTING_OLD collector to be invoked. Add -XX:+DisableExplicitGC to disable explicit garbage collection if the application does not depend on explicit garbage collection. Do not use -XX:+DisableExplicitGC if any of the following apply: (1) The application makes use of a direct buffer (e.g. java.nio.DirectByteBuffer) in combination with -XX:MaxDirectMemorySize=N[K|M|G], as the JVM uses explicit garbage collection to try to free space when MaxDirectMemorySize is reached. (2) The application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid explicit garbage collection. Reference: https://access.redhat.com/solutions/21994
warn.explicit.gc.serial=Explicit garbage collection, i.e. calls to System.gc(), is causing the slow, single threaded SERIAL_OLD collector to be invoked. Add -XX:+DisableExplicitGC to disable explicit garbage collection if the application does not depend on explicit garbage collection. Do not use -XX:+DisableExplicitGC if any of the following apply: (1) The application makes use of a direct buffer (e.g. java.nio.DirectByteBuffer) in combination with -XX:MaxDirectMemorySize=N[K|M|G], as the JVM uses explicit garbage collection to try to free space when MaxDirectMemorySize is reached. (2) The application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid explicit garbage collection. Reference: https://access.redhat.com/solutions/21994
warn.explicit.gc.serial.parallel=Explicit garbage collection, i.e. calls to System.gc(), is causing the slow, single threaded PARALLEL_SERIAL_OLD collector to be invoked. Add -XX:+DisableExplicitGC to disable explicit garbage collection if the application does not depend on explicit garbage collection. Do not use -XX:+DisableExplicitGC if any of the following apply: (1) The application makes use of a direct buffer (e.g. java.nio.DirectByteBuffer) in combination with -XX:MaxDirectMemorySize=N[K|M|G], as the JVM uses explicit garbage collection to try to free space when MaxDirectMemorySize is reached. (2) The application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid explicit garbage collection. Reference: https://access.redhat.com/solutions/21994
warn.explicit.gc.unknown=Explicit garbage collection, i.e. calls to System.gc(), is causing a full GC. Add -XX:+DisableExplicitGC to disable explicit garbage collection if the application does not depend on explicit garbage collection. Do not use -XX:+DisableExplicitGC if any of the following apply: (1) The application makes use of a direct buffer (e.g. java.nio.DirectByteBuffer) in combination with -XX:MaxDirectMemorySize=N[K|M|G], as the JVM uses explicit garbage collection to try to free space when MaxDirectMemorySize is reached. (2) The application makes remote method calls or exports remote objects like EJBs, as it can result in a memory leak due to the Distributed Garbage Collection (DGC) dependency on explicit garbage collection. To minimize DGC, test setting sun.rmi.dgc.client.gcInterval and sun.rmi.dgc.server.gcInterval to values longer than the default 1 second (JDK5 and earlier) or 1 hour (JDK6 on). For example, 4 hours (values in milliseconds): -Dsun.rmi.dgc.client.gcInterval=14400000 -Dsun.rmi.dgc.server.gcInterval=14400000. It is also possible the application depends on explicit garbage collection in some other way. For optimal performance, tune to avoid explicit garbage collection. Reference: https://access.redhat.com/solutions/21994
warn.fast.unordered.timestamps=Fast unordered timestamps are enabled with -XX:+UseFastUnorderedTimeStamps. Consider removing this option, as it is an experimental option known to cause logging issues.
warn.g1.jdk8.prior.u40=It is not recommended to use the G1 collector on JDK8 prior to update 40. Consider upgrading to the latest JDK.
warn.g1.jdk8.prior.u40.recs=JDK8 prior to update 40 the default values for G1HeapWastePercent (10) and G1MixedGCLiveThresholdPercent (65) are generally very bad. If upgrading to the latest JDK is not possible, consider setting more appropriate values: -XX:+UnlockExperimentalVMOptions -XX:G1MixedGCLiveThresholdPercent=85 -XX:G1HeapWastePercent=5.
warn.g1.mixed.gc.live.thrshld.prcnt=The occupancy threshold for a region to be considered as a candidate region for a G1_CLEANUP collection is being specified with the -XX:G1MixedGCLiveThresholdPercent=N (default 65% JDK7/JDK8 < u40, 85% JDK8u40+). Consider removing this experimental option unless there is a valid use case (e.g. JDK8 <  u40: https://bugs.openjdk.java.net/browse/JDK-8059452), and testing has shown it does not introduce any issues.
warn.gc.log.file.num.rotation.disabled=Number of GC log files is defined (-XX:NumberOfGCLogFiles), yet GC log file rotation is disabled. Either remove -XX:NumberOfGCLogFiles or enable GC log file rotation with -XX:+UseGCLogFileRotation.
warn.gc.log.file.size.small=GC log file size (-XX:GCLogFileSize=N[K|M|G]) is small (< 5M). Data needed for troubleshooting could be lost due to excessive log rotation. Consider increasing the size.
warn.gc.stopped.ratio=A significant amount of stopped time (>20%) is not GC related. Check for inverted parallelism, debugging enabled, or other JVM operations that require a safepoint: Deoptimization, PrintThreads, PrintJNI, FindDeadlock, ThreadDump, EnableBiasLocking, RevokeBias, HeapDumper, GetAllStackTrace. Analyze safepoint logging (-XX:+UnlockDiagnosticVMOptions -XX:+LogVMOutput -XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1) to determine what is causing application stopped time outside of gc. Reference: https://access.redhat.com/solutions/3973431
warn.heap.dump.initiated.gc=A garbage collection was initiated by a heap dump specifying that only live objects be included (e.g. jmap -J-d64 -dump:live,format=b,file=heap.hprof <JAVA_PID>). A heap dump significantly impacts JVM performance as it requires the JVM to be at a safepoint (all threads stopped) and should be limited to troubleshooting issues that require this heavyweight data. If a heapdump is required, consider including both live and dead objects (e.g. jmap -J-d64 -dump:format=b,file=heap.hprof <JAVA_PID>) to avoid extra, unnecessary garbage collections.
warn.heap.dump.on.oome.disabled=Remove -XX:-HeapDumpOnOutOfMemoryError and add -XX:+HeapDumpOnOutOfMemoryError instead (notice "+" vs. "-") for a heap dump to be generated when the first thread throws OutOfMemoryError. Generally this JVM argument should always be used, as it provides critical information in case of a memory error. 
warn.heap.dump.on.oome.missing=Add -XX:+HeapDumpOnOutOfMemoryError. This option does not impact performance (until the heap is actually written out); it is simply a flag to indicate that a heap dump should be generated when the first thread throws OutOfMemoryError. Generally this JVM argument should always be used, as it provides critical information in case of a memory error.
warn.heap.dump.path.filename=A heap dump file name has been specified with the -XX:HeapDumpPath (e.g. -XX:HeapDumpPath=/mydir/heapdump.hprof). Generally you only want to specify a directory (e.g. -XX:HeapDumpPath=/mydir/) and let the JVM use the default file name, which includes the process id. If you specify a file name, heap dumps will overwrite each other. Unless disk space is a concern, you typically do not want to overwrite heap dumps and lose data. Reference: https://access.redhat.com/solutions/21109
warn.heap.inspection.initiated.gc=A tool such as jmap (e.g. jmap -histo:live <JAVA_PID>) or Flight Recorder is initiating full garbage collections in order to monitor heap usage. If monitoring is excessive, it can significantly impact JVM performance (throughput).
warn.heap.min.not.equal.max=For production environments, it is recommended to set the minimum heap size (-Xms, -XX:InitialHeapSize) and the maximum heap size (-Xmx, -XX:MaxHeapSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collection the JVM has to do to resize the heap space. (2) If using large pages, memory is reserved for the JVM based on the maximum heap size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory. For example: -Xms4096M -Xmx4096M.
warn.tiered.compilation.enabled=Consider removing -XX:+TieredCompilation. It is known to cause performance issues with JDK7 (http://bugs.java.com/view_bug.do?bug_id=7159766) and JDK8 (https://bugzilla.redhat.com/show_bug.cgi?id=1420222).
warn.parallelism.inverted=There is evidence of inverted parallelism. With parallel (multi-threaded) collector events, the "user" + "sys" time should be approximately equal to the "real" (wall) time multiplied by the # of GC threads. For example, if there are 3 GC threads we would expect a parallel collection that takes 1 second of "real" time to take approximately 3 seconds of "user" + "sys" time. The parallelism is 3x. If the parallelism is 1x ("user" + "sys" = "real"), the parallel collection is not offering any efficiency over a serial (single-threaded) collection. When "user" + "sys" < "real", the parallelism is inverted. Inverted parallelism can be a sign of high i/o (e.g. disk or network access) or not enough CPU (e.g. GC threads competing with each other or other processes). Check for swapping and if the number of GC threads (-XX:ParallelGCThreads=<n>) is appropriate for the number of cpu/cores and any processes sharing cpu.
warn.perm.min.not.equal.max=For production environments, it is recommended to set the minimum permanent generation size (-XX:PermSize) and maximum permanent generation size (-XX:MaxPermSize) to equal values for the following reasons: (1) It avoids the major (full) garbage collection the JVM has to do to resize the permanent generation space. (2) If using large pages, memory is reserved for the JVM based on the maximum permanent generation size, and there is no expectation that the memory will be used by any other process. (3) If using large pages, it avoids the case when other processes using large pages exhaust the large page memory and the OS reverts to using regular pages when the JVM asks to allocate more memory. For example: -XX:PermSize=256M -XX:MaxPermSize=256M.
warn.perm.size.not.set=The permanent generation size should be explicitly set. The default permanent generation size is very small (e.g. 64MB in server mode), so not setting it can lead to OutOfMemoryError. Explicitly set the permanent generation size. For example: -XX:PermSize=128M -XX:MaxPermSize=128M.
warn.print.gc.application.concurrent.time=Remove -XX:+PrintGCApplicationConcurrentTime. It is redundant, as the same information can be calculated from the GC logging timestamps and durations. It adds overhead with no analysis value.
warn.print.class.histogram=The -XX:+PrintClassHistogram option will cause a class histogram to be output when a thread dump is taken. It is a heavyweight option that forces a full collection and can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for this option, remove it.
warn.print.class.histogram.before.full.gc=The -XX:+PrintClassHistogramBeforeFullGC option will cause a class histogram to be output before every full collection. It is a heavyweight option that can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for this option, remove it.
warn.print.class.histogram.after.full.gc=The -XX:+PrintClassHistogramAfterFullGC option will cause a class histogram to be output after every full collection. It is a heavyweight option that can output tens of thousands of logging lines. It has limited use cases for troubleshooting memory leaks. Generally memory leaks are investigated by getting a heap dump. If there is not a good use case for this option, remove it.
warn.print.commandline.flags=Add -XX:+PrintCommandLineFlags to output the JVM command line options at the beginning of the GC log. This is critical information for GC analysis.
warn.print.gc.cause.disabled=Printing trigger information is disabled with -XX:-PrintGCCause. Typically you want to enable it: -XX:+PrintGCCause. Or remove the option if using JDK8, where it is enabled by default.
warn.print.gc.cause.missing=Add -XX:+PrintGCCause to print trigger information with JDK7. For example: "GC pause (G1 Evacuation Pause) (young)" vs. "GC pause (young)". Enabled by default in JDK8.
warn.print.gc.cause.not.enabled=Printing trigger information is not enabled. This is critical information for troubleshooting serial collections. Enabled by default in JDK8+. Add -XX:+PrintGCCause to print trigger information with JDK7. Do not disable it (remove -XX:-PrintGCCause) with JDK8+.
warn.print.gc.details.disabled=PrintGCDetails is disabled. This is a standard recommended logging option that outputs details needed for GC analysis (e.g. generation, Metaspace, and Times data). Replace -XX:-PrintGCDetails with -XX:+PrintGCDetails. Or, if both -XX:-PrintGCDetails and -XX:+PrintGCDetails are specified, remove -XX:-PrintGCDetails. 
warn.print.gc.details.missing=Add -XX:+PrintGCDetails. This is a standard recommended logging option that outputs details needed for GC analysis (e.g. generation, Metaspace, and Times data).
warn.print.heap.at.gc=The -XX:+PrintHeapAtGC option is enabled. The additional data output with this option is not being used for analysis, so it is extra logging overhead. If there is not a good use case for enabling this option, remove it.
warn.print.reference.gc.enabled=Consider removing -XX:+PrintReferenceGC. garbagecat may not parse logs with this option, resulting in many unidentified log lines. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less verbose logging.
warn.print.string.dedup.stats.enabled=Consider removing -XX:+PrintStringDeduplicationStatistics. It is not a standard recommended GC logging option and is typically only enabled for special troubleshooting/analysis. If there is no reason to use it, remove it for less verbose logging.
warn.print.tenuring.distribution=The -XX:+PrintTenuringDistribution option is enabled. The additional data output with this option is not being used for analysis, so it is extra logging overhead. If there is not a good use case for enabling this option, remove it.
warn.rmi.dgc.client.gcInterval.redundant=The sun.rmi.dgc.client.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
warn.rmi.dgc.client.gcInterval.small=The sun.rmi.dgc.client.gcInterval value is small. A typical value is at least one hour (e.g. -Dsun.rmi.dgc.client.gcInterval=3600000).
warn.rmi.dgc.server.gcInterval.redundant=The sun.rmi.dgc.server.gcInterval option can be removed as it has no affect when explicit garbage collection is disabled (-XX:+DisableExplicitGC).
warn.rmi.dgc.server.gcInterval.small=The sun.rmi.dgc.server.gcInterval value is small. A typical value is at least one hour (e.g. -Dsun.rmi.dgc.server.gcInterval=3600000).
warn.tenuring.disabled=Tenuring has been disabled with -XX:MaxTenuringThreshold=0 or by setting it to a value greater than 15 (e.g. -XX:MaxTenuringThreshold=32), resulting in objects surviving a young collection not being copied to a survivor space but being immediately promoted to the old generation. Unless testing has shown this makes sense for your application (e.g. mainly long live objects), consider removing this option to allow the default value to be applied.
warn.thread.stack.size.large=The thread stack size is on the large side (>= 1024k). Typical values are 128k (32-bit) or 256k (64-bit). If the JVM is 32-bit, consider testing to confirm a large thread stack size is needed. This is not an issue on 64-bit unless the unused memory results in physical memory exhaustion and swapping; however, 32-bit memory constraints generally require freeing unneeded thread stack memory to allow a larger heap.
warn.thread.stack.size.not.set=If the JVM is 32-bit, consider explicitly setting the thread stack size with the -Xss (n/a Solaris) or -XX:ThreadStackSize option. The default size is typically much larger than needed. This is not an issue on 64-bit unless the unused memory results in physical memory exhaustion and swapping; however, 32-bit memory constraints generally require freeing unneeded thread stack memory to allow a larger heap.
warn.trace.class.unloading=The -XX:+TraceClassUnloading option is enabled, causing class unloading information to be output. This data is not being used for analysis. If there is not a good use case for enabling this option, remove it or disable (-XX:-TraceClassUnloading) it.
warn.unidentified.log.line.report=Unidentified log line(s). Please submit an issue so we can investigate: https://github.com/mgm3746/garbagecat/issues.
warn.use.membar=The -XX:+UseMembar option is being used. This was a workaround for a bug in old versions of JDK 1.6 (see http://bugs.java.com/view_bug.do?bug_id=6822370) and is not necessary with modern JVMs. If there is not a good use case for using this option, remove it, as it causes the JVM to use a memory barrier that slows down the JVM. 